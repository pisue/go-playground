# 🧠 Go gRPC 개발 핵심 개념: 구조체와 상태 관리

이 문서는 `grpc-server` 모듈을 개발하면서 마주친, **Go 언어의 구조체(Struct), 포인터, 그리고 데이터 흐름**에 대한 헷갈리는 개념들을 비유를 통해 쉽게 정리한 문서입니다.

Java나 Spring 개발자가 Go의 구조체 포인터 기반 설계를 처음 접할 때 흔히 갖는 의문점들을 해소하는 것을 목표로 합니다.

---

## 1. 왜 `Client` 구조체를 상단에 따로 만들까요? (도구함 만들기)

```go
type GRPCClient struct {
    client      *grpc.ClientConn        // 전화기 (연결 객체)
    authClient  auth.AuthServiceClient  // 통화할 상대방 (gRPC 클라이언트)
    pasetoMaker *paseto.PasetoMaker     // 도장 (토큰 생성기)
}
```

Go에서 이런 구조체는 **'일을 처리하는 전문 일꾼(Worker)'** 또는 **'잘 정리된 도구함'**이라고 생각하면 됩니다.

### ❓ 의문점
> "그냥 함수마다 필요한 변수(`client`, `config`)를 그때그때 넘겨주면 안 되나요?"

### 💡 답변: "도구함을 챙겨 다니세요!"
배관공이 수리를 하러 갈 때, 망치, 렌치, 드라이버를 **손에 주렁주렁 들고(Parameter)** 다니면 불편하겠죠?
대신 **공구함(Struct)**에 모든 도구를 딱 정리해서 넣어두면, 공구함 하나만 들고 다니며 언제든 필요한 도구를 꺼내 쓸 수 있습니다.

*   **구조체(Struct)** = 공구함
*   **필드(Field)** = 공구함 안의 도구들 (망치, 렌치)
*   **메서드(Method)** = 배관공이 공구함을 열어 작업을 수행하는 행위

---

## 2. Config 포인터를 공유하면 다 똑같은 걸 보게 되나요? (은행 지점 비유)

### ❓ 의문점
> "`NewGRPCClient(cfg *config.Config)` 처럼 설정을 포인터로 넘기면, 모든 클라이언트가 똑같은 설정을 바라보게 되잖아요. 그래도 되나요?"

### 💡 답변: "네, 그래야만 합니다!"

이 상황을 **은행 지점**에 비유해 보겠습니다.

*   **은행 지점 (`GRPCClient`)**: 고객을 응대하는 곳
*   **은행 본점 전산망 주소 (`Config`)**: 송금을 처리하는 중앙 서버의 주소

철수(Client A)가 오든, 영희(Client B)가 오든, **모든 창구 직원은 '동일한 본점 전산망'에 접속해야 합니다.**
만약 직원마다 접속하는 전산망 주소가 다르다면? 철수의 돈은 A 은행으로, 영희의 돈은 B 은행으로 가버리는 대형 사고가 터지겠죠.

따라서 `Config`와 같은 **환경 설정, 연결 정보**는 포인터로 공유하여 **"모두가 100% 동일한 값"**을 바라보게 하는 것이 정석입니다. 메모리도 아끼고, 데이터의 일관성(Consistency)도 지킬 수 있습니다.

---

## 3. 그럼 여러 명의 유저 정보(Data)는 어떻게 구분하나요?

### ❓ 의문점
> "구조체를 하나만 만들어 공유하면, 철수 데이터랑 영희 데이터가 섞이는 거 아닌가요?"

### 💡 답변: "직원(Tool)과 손님(Data)을 구분하세요!"

여기서 가장 중요한 핵심은 **"구조체에는 '도구'만 넣고, '데이터'는 넣지 않는다"**는 것입니다.

다시 은행 창구로 돌아가 봅시다.

*   **창구 직원 (`GRPCClient`)**: 컴퓨터와 도장을 가지고 있음. **(고정된 존재 / Shared)**
*   **찾아온 손님 (`Method Parameter`)**: 철수, 영희, 민수... **(매번 바뀜 / Transient)**

```go
// 직원(g)은 자리에 계속 앉아있지만, 손님(address)은 계속 바뀝니다.
func (g *GRPCClient) CreateAuth(address string) ... {
    // 1. g.pasetoMaker (직원의 도장)를 꺼낸다.
    // 2. address (이번에 온 손님 이름)를 찍는다.
    // 3. 결과물을 내준다.
}
```

1.  **`GRPCClient` (직원)**: 한 번 출근(초기화)하면 퇴근할 때까지 그 자리에 있습니다. 도구도 그대로 씁니다.
2.  **`address` (손님)**: 함수가 호출될 때 잠깐 왔다가, 처리가 끝나면 사라집니다.

철수가 왔을 때 직원이 철수 이름을 도장으로 찍어준다고 해서, 직원의 도장에 철수 이름이 영원히 새겨지는 건 아니죠?
다음엔 영희가 오면 똑같은 도장으로 영희 이름을 찍어줄 수 있습니다.

### 📝 요약 정리

| 구분 | 역할 | 비유 | 수명 (Life Cycle) | 위치 |
| :--- | :--- | :--- | :--- | :--- |
| **구조체 필드**<br>(`client`, `maker`) | 일을 하기 위한 **도구** | 은행 직원, 컴퓨터, 도장 | 애플리케이션 실행 내내 유지 | `Heap` 메모리 (주로) |
| **메서드 파라미터**<br>(`address`, `token`) | 처리해야 할 **재료(데이터)** | 창구에 찾아온 손님 | 함수 호출 시 생성 ~ 종료 시 소멸 | `Stack` 메모리 |

**"도구는 공유하고, 재료는 그때그때 받아서 쓴다."**
이 원칙만 기억하면 구조체 포인터 설계가 훨씬 쉬워질 것입니다.
