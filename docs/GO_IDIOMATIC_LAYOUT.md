# 📂 프로젝트 구조: 왜 ‘Go 스럽다’를 지향하는가?

이 프로젝트는 Go 커뮤니티에서 권장되는 **Standard Project Layout**을 기반으로 설계되었습니다. 단순히 보기 좋은 구조를 넘어, Go 언어의 철학과 컴파일러의 특성을 가장 잘 활용하는 **‘Go 스러운’** 구조를 선택한 이유를 설명합니다.

---

## 1. ‘Go 스럽다’는 것의 의미

Go는 단순함(Simplicity)과 실용성(Pragmatism)을 중요하게 여깁니다. 프로젝트 구조에서 ‘Go 스럽다’는 것은 다음과 같은 가치를 실현하는 것을 의미합니다.

* **명확한 의도**: 폴더명만 보고도 해당 코드가 실행 파일인지, 내부 로직인지 바로 알 수 있어야 합니다.
* **엄격한 캡슐화**: 외부에서 수정하면 안 되는 코드는 물리적으로 격리합니다.
* **순환 참조 방지**: 패키지 간의 의존 관계를 명확히 하여 복잡성을 줄입니다.

---

## 2. 핵심 디렉토리 선정 이유

### 🚀 `cmd/` : 애플리케이션의 시작점

* Go 프로젝트에서 실행 가능한 메인 함수(`main.go`)는 `cmd/` 폴더 아래에 위치하는 것이 관례입니다.
* **선택 이유**: 프로젝트가 커져서 API 서버 외에 마이그레이션 툴이나 배치 작업(Worker)이 추가되더라도, `cmd/app`, `cmd/worker` 등으로 확장하기 매우 용이합니다.

### 🔒 `internal/` : Go 컴파일러가 보장하는 보안

* Go에는 `internal`이라는 이름의 디렉토리에 있는 코드를 **외부 프로젝트에서 import 할 수 없도록** 하는 컴파일러 레벨의 제약이 있습니다.
* **선택 이유**: 우리 서비스의 핵심 비즈니스 로직이 외부 라이브러리처럼 오용되는 것을 방지하고, 프로젝트 내부에서만 응집력 있게 사용되도록 강제합니다. 이는 가장 ‘Go 스러운’ 캡슐화 방식입니다.

### 🏗️ `handler-service-repository` : 책임의 분리

* **Handler**: HTTP 요청을 받고 응답을 돌려주는 인터페이스 역할에 집중합니다.
* **Service**: 순수한 비즈니스 로직을 담당하며, 특정 프레임워크에 의존하지 않습니다.
* **Repository**: 데이터베이스나 외부 저장소와의 통신을 전담합니다.
* **선택 이유**: 계층 간 역할이 분명해져 코드 가독성이 높아지며, 각 계층을 독립적으로 테스트(Unit Test)하기에 최적화된 구조입니다.

---

## 3. 구조 요약도

```text
board/
├── cmd/                # 서비스의 진입점 (컴파일 대상)
│   └── app/main.go     # 애플리케이션 메인 실행 파일
├── internal/           # 외부에서 참조 불가능한 내부 로직 (캡슐화)
│   ├── handler/        # Controller 역할 (HTTP/gRPC 입출력)
│   ├── service/        # Business Logic (핵심 도메인 로직)
│   ├── repository/     # Data Access (DB, Cache)
│   └── model/          # DTO 및 엔티티 정의
├── pkg/                # 외부 프로젝트에서도 재사용 가능한 유틸리티
└── configs/            # 환경 설정 및 설정 파일

```

---

## 4. 기대 효과

이러한 ‘Go 스러운’ 구조를 채택함으로써 얻는 이점은 명확합니다.

1. **유지보수 효율**: 새로운 팀원이 합류해도 Go 표준 구조를 알고 있다면 코드 위치를 즉시 파악할 수 있습니다.
2. **테스트 용이성**: 인터페이스 기반의 계층 분리를 통해 Mocking이 쉬워지고 테스트 커버리지를 높일 수 있습니다.
3. **확장성**: 프로젝트 규모가 커지더라도 폴더 구조를 갈아엎지 않고도 유연하게 기능을 추가할 수 있습니다.

---

**이 프로젝트는 Go의 관습을 존중하며, 단순하고 명확한 코드를 작성하는 것을 최우선 가치로 삼습니다.**
