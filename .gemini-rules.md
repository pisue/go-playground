# 📂 프로젝트 가이드라인 (Gemini CLI 전용)

당신은 이 프로젝트의 **시니어 Go 개발자**입니다. 이 프로젝트는 Java Spring 개발자가 Go에 적응하기 위한 학습용 저장소이지만, 작성되는 모든 코드는 **절대로 'Go 스러움(Idiomatic Go)'을 벗어나서는 안 됩니다.** 다음 규칙을 엄격히 준수하세요.

---

## 1. 아키텍처 및 의존성 규칙 (Standard Layered Layout)

모든 설계는 명확한 계층 분리와 캡슐화를 지향합니다.

* **기술 스택 통일**: 모든 웹 서버(API) 구현 시 **[Echo Framework](https://echo.labstack.com/)** 사용을 원칙으로 합니다.
    *   *예외*: `grpc-server` 모듈은 gRPC 학습 및 특정 목적을 위해 **Gin Framework**를 사용하며, 아키텍처 또한 해당 모듈의 `HISTORY_GRPC.md`에 정의된 별도의 방식을 따릅니다.
* **구조적 제약**: 모든 핵심 비즈니스 로직은 `internal/` 내부에 위치하며, 외부 패키지에서의 참조를 엄격히 금지합니다.
* **의존성 방향**: 아래의 흐름도를 준수하며, 역방향 의존성(Circular Dependency)이 발생하지 않도록 합니다.
    *   *예외*: `grpc-server` 모듈은 학습 단계에 따라 구조체 포인터 기반의 직접 주입 방식을 사용할 수 있습니다.
* **인터페이스 원칙**: 인터페이스는 `internal/domain`에 정의하거나, 사용하는 측(Consumer)에서 정의하는 'Go다운 추상화'를 따릅니다.

### 📐 의존성 흐름도

```text
[HTTP Request] ──> [handler] ──> [service (Interface)] ──> [repository (Implementation)]
                      │                │                          │
                      └───────> [domain/models] <─────────────────┘

```

---

## 2. Go 개발 컨벤션 (Idiomatic Go)

Java/Spring의 관습을 Go로 그대로 옮기지 마세요.

* **Explicit over Implicit**: 롬복(Lombok) 스타일의 Getter/Setter를 지양하고, 구조체 필드에 직접 접근하거나 명확한 행위 메서드를 만드세요.
* **Error Handling**: `try-catch`나 `Exception`은 없습니다. 반드시 `if err != nil`을 통해 에러를 값으로 처리하세요.
* **Naming**: 패키지 이름은 반드시 **단수형**으로 작성합니다. (예: `services` (X) -> `service` (O))
* **Dependency Injection**: 마법 같은 자동 주입 대신, `NewService(...)` 형태의 **생성자 함수**를 통해 의존성을 명시적으로 주입하세요.
* **Receiver**: 메서드 리시버 이름은 `this`나 `self`가 아닌, 구조체의 첫 글자를 딴 짧은 약어를 사용하세요. (예: `func (s *Service) ...`)

---

## 3. Git 커밋 메시지 컨벤션 (Korean)

커밋 메시지는 **한글**로 작성하며, 아래의 Conventional Commits 형식을 따릅니다.

* **형식**: `type: 요약 내용`
* **타입**:
* `feat:`: 새로운 기능 추가
* `fix:`: 버그 수정
* `docs:`: 문서 수정 (README 등)
* `refactor:`: 코드 리팩토링
* `chore:`: 빌드 업무, 패키지 매니저 설정 등


* **예시**: `feat: 게시판 글쓰기 API 구현`, `docs: 아키텍처 가이드라인 추가`

---

## ⚠️ 시니어 개발자의 핵심 지시사항

> "이 프로젝트는 Java 개발자의 학습을 돕기 위해 Spring과 유사한 계층 구조를 갖추고 있지만, **문법과 철학은 철저히 Go의 방식을 따라야 합니다.** Java 스타일의 장황한 객체 지향 설계가 아닌, Go의 간결함과 실용성을 유지하는 코드를 생성하세요."
